Enforce schema
Enforce semantics
Add new UI elements to component library
use shared for registering
Zod exists
Reuse existing elements whenever possible.
Code withing bounding canonical datatypes and use cases
Do not code new styles or components or modules inline

Database Conventions
Naming
Tables: snake_case plural (e.g., hierarchy_nodes, task_references)
Columns: snake_case (e.g., parent_id, source_record_id)
Types/Enums: snake_case (e.g., node_type, ref_mode)
UUIDs
All primary keys use gen_random_uuid()
Enables collision-free cloning and distributed systems
JSONB Patterns
schema_config.fields[]: Array of field definitions
data: Key-value pairs matching schema field keys
metadata: Flexible node-specific configuration
API Conventions
Backend (Fastify)
Request/Response: camelCase (e.g., schemaConfig, definitionId)
Zod schemas for validation
Standard response wrappers: { node }, { records }, { reference }
Frontend (React + TanStack Query)
Types use database column names (snake_case) for data types
API input types use camelCase to match backend expectations
Mutations invalidate relevant query keys
Migration Requirements
CRITICAL: Always Keep Migrations Updated
When adding new features that require database changes:

Check if migration exists for the table/column
Create new migration if schema change is needed
Add seed data for required default records (e.g., node type definitions)
Run migrations to verify: npm run migrate
Update schema.ts if types change

## Frontend Architecture Patterns

### Page vs View vs Surface

- **Page** (`/pages/*.tsx`): Route-level shell. Minimal logic. Composes:
  - `Header` component
  - Left sidebar/panel (via resizable aside)
  - Center View component
  - Right Inspector (via `SelectionInspector` or domain-specific)
  - `BottomDrawer` for modals/dialogs
  - `ResizeHandle` between panels

- **View** (`/surfaces/{domain}/*View.tsx`): The main workspace content. Receives state via props from Page. Contains preview tabs, tables, or visualization.

- **Sidebar** (`/surfaces/{domain}/*Sidebar.tsx`): Left panel for configuration, navigation, or source selection. Receives state via props from Page.

- **Inspector** (`/surfaces/{domain}/*Inspector.tsx`): Right panel for detailed inspection of selected items.

### State Flow

Pages own state and pass down via props:
```tsx
// Page pattern
const [session, setSession] = useState<Session | null>(null);
const [selectedId, setSelectedId] = useState<string | null>(null);

<Sidebar session={session} onSessionCreated={setSession} />
<View session={session} selectedId={selectedId} onSelect={setSelectedId} />
<Inspector selectedId={selectedId} />
```

For complex global state, use Zustand stores (e.g., `useUIStore`, `useImportWorkbenchStore`).

### Drawer Pattern

Use `openDrawer(type, context)` from `useUIStore` for modal-like interactions:
- `'monday-boards'` - board selection
- `'classification'` - classification review
- `'integrations'` - API connections
- `'create-node'`, `'create-record'` - creation forms

### Naming Conventions

| File | Purpose |
|------|---------|
| `{Domain}Page.tsx` | Route shell in `/pages/` |
| `{Domain}View.tsx` | Center content in `/surfaces/{domain}/` |
| `{Domain}Sidebar.tsx` | Left panel in `/surfaces/{domain}/` |
| `{Domain}Inspector.tsx` | Right panel in `/surfaces/{domain}/` |
| `{Domain}Content.tsx` | Alternative center content (if multiple views exist) |

### Reference Files

- `ProjectPage.tsx` - canonical page pattern
- `ProjectWorkflowView.tsx` - complex view with sidebar integration
- `ImportPage.tsx` - import workbench pattern

### UI Atoms

Use bespoke components from `ui/atoms`:
- `Badge`, `Button`, `Card`, `Checkbox`, `Inline`, `Stack`, `Text`, `TextInput`, `Select`, `Spinner`, `RadioGroup`, `Alert`

Do NOT use Mantine components. All UI must use bespoke atoms or custom implementations.
